from PyQt4.QtCore import *
from PyQt4.QtGui import *
import json
import diggerconf

def mushUnEscape(str):
	retStr = ""
	x = 0
	while x != len(str):
		if str[x] == "%":
			x += 1
			if str[x] == "%":
				retStr += "%"
			elif str[x] == "r":
				retStr += "\n"
			else:
				retStr += str[x]
		else:
			retStr += str[x]
		x += 1
	return retStr

def mushEscape(str):
	retStr = ""
	x = 0
	while x != len(str):
		if str[x] == "%":
			retStr += "%%"
		elif str[x] == "\n":
			retStr += "%r"
		else:
			retStr += str[x]
		x += 1
	return retStr


def saveToJson(fname, parent, rooms, exits, labels):
	fsave = QFile(fname)
	if not fsave.open(QIODevice.WriteOnly):
		raise IOError, unicode(fsave.errorString())
	stream = QTextStream(fsave)
	stream.setCodec("UTF-8")
	stream << ('{\n')
	stream << ('\t"map": {\n')
	stream << ('\t\t"width": %d,\n' % parent.ui.scene.width())
	stream << ('\t\t"height": %d,\n' % parent.ui.scene.height())
	stream << ('\t\t"bcolor": "%s",\n' % parent.bColor)

	jroomList = []
	for i, room in rooms.iteritems():
		jroomList.append({
		"id":i,
		"x":room.x,
		"y":room.y,
		"bcolor":room.bColor,
		"size":room.center,
		"name":unicode(room.name),
		"description":unicode(mushEscape(room.desc)),
		"code":[unicode(x) for x in room.code]
		})
	stream << ('\t\t"rooms":\n\t\t' + json.dumps(jroomList, indent = 4).replace('\n', '\n\t\t') + ',\n')

	jexitList = []
	for i, exit in exits.iteritems():
		jexitList.append({
		"id":i,
		"source":exit.source,
		"destination":exit.dest,
		"name":unicode(exit.name),
		"description":unicode(mushEscape(exit.desc)),
		"alias":unicode(exit.alias)
		})
	stream << ('\t\t"exits":\n\t\t' + json.dumps(jexitList, indent = 4).replace('\n', '\n\t\t') + ',\n')

	jlabelList = []
	for i, label in labels.iteritems():
		jlabelList.append({
		"x":label.x,
		"y":label.y,
		"text":unicode(label.normalText)
		})
	stream << ('\t\t"labels":\n\t\t' + json.dumps(jlabelList, indent = 4).replace('\n', '\n\t\t') + '\n')
	stream << ('\t}\n')
	stream << ('}\n')

def saveToXml(fname, parent, rooms, exits, labels):
	fsave = QFile(fname)
	if not fsave.open(QIODevice.WriteOnly):
		raise IOError, unicode(fsave.errorString())
	stream = QTextStream(fsave)
	stream.setCodec("UTF-8")
	stream << ("<?xml version='1.0' encoding='UTF-8'?>\n" + "<!DOCTYPE DIGGER>\n" + "<DIGGER VERSION='%s'>\n" % (diggerconf.version))
	stream << ("<map width='%d' height='%d' bcolor='%s'>\n" % (parent.ui.scene.width(), parent.ui.scene.height(), parent.bColor))
	for i, room in rooms.iteritems():
		stream << ("\t<room id='%d' x='%d' y='%d' bcolor='%s' size='%d'>\n" % (i, room.x, room.y, room.bColor, room.center))
		stream << "\t\t<name>" << Qt.escape(room.name) << "</name>\n"
		if room.desc != "":
			stream << "\t\t<description>" << mushEscape(Qt.escape(room.desc)) << "</description>\n"
		if room.code:
			for codeLine in room.code:
				stream << "\t\t<code>" << Qt.escape(codeLine) << "</code>\n"
		stream << "\t</room>\n"
	for i, exit in exits.iteritems():
		stream << ("\t<exit id='%d' source='%d' destination='%d'>\n" % (i, exit.source, exit.dest))
		stream << "\t\t<name>" << Qt.escape(exit.name) << "</name>\n"
		if exit.desc != "":
			stream <<"\t\t<description>" << mushEscape(Qt.escape(exit.desc)) << "</description>\n"
		if exit.alias != "":
			stream << "\t\t<alias>" << Qt.escape(exit.alias) << "</alias>\n"
		stream << "\t</exit>\n"
	for i, label in labels.iteritems():
		stream << ("\t<label x='%d' y='%d'>" % (label.x, label.y))
		stream << Qt.escape(label.normalText)
		stream << "</label>\n"
	stream << "</map>\n</DIGGER>"

def generateCode(title, rooms, exits, labels):
	def isCode(codelist):
		if codelist:
			if codelist[0] == "" and len(codelist) == 1:
				return False
			return True
		return False
	strExport = "@@ Generated by Digger v" + diggerconf.version + "\n" + "@@ " + title + "\n"
	for k, room in rooms.iteritems():
		strExport += "@dig/teleport " + room.name + "\n"
		if room.desc != "":
			strExport += "@desc here=" + mushEscape(str(room.desc)) + "\n"
		strExport += "think set(me, " + diggerconf.attributePrefix + str(k) + ":%l)\n"

	for k, room in rooms.iteritems():
		sourceExits = []
		for j, exit in exits.iteritems():
			if exit.source == k: # Select source exits
				sourceExits.append(exit)
		if isCode(room.code) or sourceExits:
			strExport += "@tel [v(" + diggerconf.attributePrefix + str(k) + ")]\n"
		for j in sourceExits:
			aliasString = ""
			if j.alias != "":
				aliasString += ";" + j.alias
			if j.dest != -1:
				strExport += "@open " + j.name + aliasString + "=[v(" + diggerconf.attributePrefix + str(j.dest) + ")]\n"
			else:
				strExport += "@open " + j.name + aliasString + "\n"
			if j.desc != "":
				strExport += "@desc " + j.name + "=" + mushEscape(str(j.desc)) + "\n"
		if isCode(room.code):
			if diggerconf.enableImports:
				for codeLine in room.code:
					codeWords = codeLine.split()
					if codeWords[0] == "@@@" and codeWords[1] == "import":
						fname = str(" ".join(codeWords[2:]))
						if os.path.isfile(fname):
							strExport += "@@ Import file: " + fname + "\n"
							with open(str(fname), 'r') as codeFile:
								strExport += codeFile.read() + "\n"
						else:
							strExport += "@@ Import file: " + fname + " not found.\n"
					else:
						strExport += codeLine + "\n"
			else:
				for codeLine in room.code:
					strExport += codeLine + "\n"
	if diggerconf.clearAttributes:
		for k in rooms:
			strExport += "&" + diggerconf.attributePrefix  + str(k) + " me\n"
	if diggerconf.exportLabels:
		for k, label in labels.iteritems():
			strExport += "think LABEL: *** " + label.normalText + " ***\n"
	return strExport

